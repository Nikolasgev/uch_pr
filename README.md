## Remote Content Harvester

Полноценный пример клиент-серверного приложения, которое:

- хранит на сервере соответствие ключевых слов и списка внешних URL;
- выдаёт список URL по ключевому слову и скачивает выбранный ресурс через сервер, передавая размер/прогресс;
- сохраняет результат в `localStorage`, чтобы читать офлайн;
- показывает пользователю состояние загрузки и все ошибки.

Проект разделён на две части:

| Папка   | Содержание                                                                 |
|---------|-----------------------------------------------------------------------------|
| `server` | Node.js/Express-сервер, который хранит словарь URL, проксирует загрузку и отдаёт клиенту статические файлы. |
| `client` | React + Vite SPA с AJAX-взаимодействием, прогресс-баром и офлайн-библиотекой. |

---

### Требования

- Node.js >= 18.18 (используется `Readable.fromWeb` и встроенный `fetch`)
- npm >= 10
- Доступ в интернет для загрузки внешних ресурсов из списка.

---

### Быстрый старт (локально)

```bash
git clone <repo-url>
cd uch_pr
npm install            # установит зависимости корня + подпроектов
npm run dev            # параллельно поднимет сервер (4000) и клиент (5173)
```

Полезные скрипты:

| Команда              | Описание                                              |
|----------------------|-------------------------------------------------------|
| `npm run dev`        | Dev-сервер Express (`localhost:4000`) + Vite (`5173`). |
| `npm run dev:server` | Только backend с hot-reload через `nodemon`.          |
| `npm run dev:client` | Только фронтенд.                                      |
| `npm run build`      | Сборка клиента (`client/dist`).                        |
| `npm start`          | Запуск production-сервера Express (ожидает собранный клиент). |

> В режиме разработки Vite проксирует все запросы `/api/*` на `http://localhost:4000`, поэтому CORS- и cookie-настройки дополнительные не нужны.

---

### Переменные окружения

| Путь        | Файл          | Назначение                                                                 |
|-------------|---------------|---------------------------------------------------------------------------|
| `server`    | `env.example` | `PORT`, `ALLOWED_ORIGINS`, `DOWNLOAD_TIMEOUT_MS`. Скопируйте в `.env`.     |
| `client`    | `env.example` | `VITE_API_BASE_URL` (опционально). Пустое значение = использовать относительные пути и прокси. |

---

### API cервера

| Метод | Маршрут                   | Описание                                                    |
|-------|---------------------------|-------------------------------------------------------------|
| GET   | `/api/health`             | Быстрая проверка состояния.                                |
| GET   | `/api/keywords`           | Список доступных ключевых слов + количество URL.           |
| GET   | `/api/keywords/:keyword`  | Возвращает URL, разрешённые для заданного ключа.           |
| POST  | `/api/download`           | Тело `{ keyword, resourceId }`. Устанавливает заголовки `X-Remote-Content-*` и потоково проксирует контент. |

Сервер обнуляет опасность "открытого прокси": скачивать можно только URL, описанные в `server/src/data/keywordLibrary.js`.

---

### Клиент

- Использует `fetch` + потоковое чтение `ReadableStream`, чтобы вычислять прогресс (на основании `Content-Length/X-Remote-Content-Length`).
- Интерактивно показывает пользователю:
  - прогресс-бар;
  - размер скачанного и общий размер (если известен);
  - список офлайн-файлов (хранятся в `localStorage` под ключом `offline-library-v1`);
  - удобные сообщения об ошибках (сетевых, серверных, таймаутах).
- Позволяет открыть сохранённый документ без сети, удалить запись, посмотреть метаданные.

---

### Сборка и production

1. Соберите клиент: `npm run build`.
2. Express автоматически начнёт раздавать `client/dist` (проверяется в `server/src/server.js`).
3. Запустите `npm start` (или `npm run start --prefix server`) — сервер поднимется на `PORT` и будет отдавать и API, и статические файлы.

---

### Публичное развёртывание

Чтобы выполнить требование «рабочий результат доступен публично», можно использовать любую PaaS (Render, Railway, Fly.io). Пример для [Render](https://render.com):

1. Залейте репозиторий на GitHub/GitLab.
2. Создайте новый **Web Service**:
   - Build command: `npm install && npm run build`
   - Start command: `npm start`
   - Environment: Node 18 или выше.
3. Render запустит `npm run build`, соберёт клиент и сохранит его в `client/dist`.
4. `npm start` запустит Express, который будет сразу обслуживать и API, и статический фронтенд.

Альтернатива с двумя сервисами:

- Backend на Render/Fly (`npm start`).
- Frontend на Vercel/Netlify (`npm run build` + `dist`). В этом случае в переменных окружения Vercel укажите `VITE_API_BASE_URL=https://<backend-host>.onrender.com`.

После деплоя добавьте ссылку на работающий инстанс в описание репозитория.

---

### Тестирование

Авто-тестов нет; рекомендуется ручная проверка сценариев:

1. Поиск по каждому ключевому слову и проверка списка URL.
2. Скачивание ресурса, наблюдение прогресса, проверка записи в офлайн-библиотеке.
3. Перезагрузка страницы и просмотр ранее сохранённого контента без сети (можно включить `offline` в DevTools).
4. Проверка обработки ошибок (например, остановить сервер и убедиться, что клиент показывает сообщение).

---

### Полезные ссылки

- `server/src/data/keywordLibrary.js` — словарь ключевых слов и безопасных URL.
- `client/src/App.tsx` — основная бизнес-логика клиента.
- `server/src/server.js` — конфигурация Express и потоковая прокси-загрузка.

При необходимости расширяйте список ключевых слов или подключайте БД — текущая архитектура это позволяет.


